# 04_アーキテクチャ設計

## 概要

このドキュメントでは、Traincrew_MultiATS_Server プロジェクトのアーキテクチャ設計思想、プロジェクト構成、レイヤー設計について説明します。

---

## 1. プロジェクト構成

### 1.1 全体構成（6プロジェクト）

```
┌─────────────────────────────────────────────────────┐
│         Traincrew_MultiATS_Server.Crew              │ ← 乗務員用Web API/SignalR
│      Traincrew_MultiATS_Server.Passenger            │ ← お客様用Web API/SignalR
└──────────────────┬──────────────────────────────────┘
                   │ 依存
                   ▼
┌─────────────────────────────────────────────────────┐
│       Traincrew_MultiATS_Server                     │ ← コアビジネスロジック
│  (Models, Repositories, Services, Hubs)             │
└──────────────────┬──────────────────────────────────┘
                   │ 依存
                   ▼
┌─────────────────────────────────────────────────────┐
│     Traincrew_MultiATS_Server.Common                │ ← クライアント/サーバー共通スキーマ
│  (SignalRコントラクト、共有Body)                      │
└─────────────────────────────────────────────────────┘

        ┌─────────────────┐
        │    IT / UT      │ ← テストプロジェクト
        └─────────────────┘
```

### 1.2 各プロジェクトの責務

| プロジェクト | 種別 | 責務 |
|------------|------|------|
| **Traincrew_MultiATS_Server.Crew** | Web | 乗務員向けHTTP API・SignalRエンドポイント提供 |
| **Traincrew_MultiATS_Server.Passenger** | Web | お客様向けHTTP API・SignalRエンドポイント提供 |
| **Traincrew_MultiATS_Server** | Library | ビジネスロジック、データアクセス、Hub実装 |
| **Traincrew_MultiATS_Server.Common** | Library | クライアント/サーバー間の共通スキーマ定義 |
| **Traincrew_MultiATS_Server.IT** | Test | 統合テスト |
| **Traincrew_MultiATS_Server.UT** | Test | ユニットテスト |

---

## 2. レイヤードアーキテクチャ

### 2.1 データフロー

```
Controller/Hub → Service → Repository → DbContext → PostgreSQL
      ↑            ↑           ↑            ↑
      │            │           │            │
   HTTPリクエスト  │       データアクセス    EF Core
   SignalR        ビジネス     抽象化       ORM
   エンドポイント  ロジック
```

### 2.2 各層の責務

| 層 | ディレクトリ | 責務 | 実装例 |
|---|------------|-----|--------|
| **Presentation層** | `Crew/Controllers`<br>`Crew/Hubs` | HTTP/SignalRエンドポイント提供<br>リクエスト検証<br>レスポンス整形 | `TrainHub.cs`<br>`InterlockingHub.cs` |
| **Service層** | `Services/` | ビジネスロジック実装<br>複数Repositoryの統合<br>トランザクション制御 | `RouteService.cs`<br>`InterlockingService.cs`<br>`TrainService.cs` |
| **Repository層** | `Repositories/` | データアクセス抽象化<br>クエリカプセル化<br>CRUD操作定義 | `RouteRepository.cs`<br>`SignalRepository.cs`<br>`TrackCircuitRepository.cs` |
| **Data層** | `Data/`<br>`Models/` | EF Core DbContext<br>エンティティ定義<br>データベースマッピング | `ApplicationDbContext.cs`<br>`Route.cs`<br>`Signal.cs` |
| **Contract層** | `Common/Contract`<br>`Common/Models` | SignalRインターフェース定義<br>共有Body定義 | `IInterlockingHubContract.cs`<br>`Interlocking.cs` |

### 2.3 層のアクセス制限

#### 許可されるアクセス

- ✅ **Controller/Hub** → **Service** → **Repository** → **DbContext**
- ✅ **Service** が複数の **Repository** を組み合わせる
- ✅ **Repository** のみが **DbContext** にアクセス

#### 禁止されるアクセス

- ❌ **Controller/Hub** が **DbContext** を直接利用
- ❌ **Service** が **DbContext** を直接利用
- ❌ **Controller/Hub** が **Repository** を直接利用（Serviceを経由すること）

**理由:**
- テスタビリティの向上（各層を独立してテスト可能）
- 関心の分離（データアクセスロジックとビジネスロジックの分離）
- 保守性の向上（変更の影響範囲を限定）

---

## 3. 主要設計パターン

### 3.1 Repository パターン

**目的:** データアクセスロジックをカプセル化し、ビジネスロジックから分離する

**実装:**
- 各エンティティに対して専用のRepositoryを配置
- インターフェース（例: `IRouteRepository`）で操作を定義
- 実装クラス（例: `RouteRepository`）でEF Coreを使用

**例:**
```csharp
// インターフェース定義 (Repositories/Route/IRouteRepository.cs)
public interface IRouteRepository
{
    /// <summary>
    /// IDから進路を取得する
    /// </summary>
    Task<List<Models.Route>> GetByIdsWithState(List<ulong> ids);

    /// <summary>
    /// てこ反応リレーが扛上しているすべての進路IDを取得する
    /// </summary>
    Task<List<ulong>> GetIdsWhereLeverRelayIsRaised();

    /// <summary>
    /// てこ反応リレーが落下しており かつ 転てつ器無し進路照査リレーが扛上している進路に対し、
    /// 転てつ器無し進路照査リレーを落下させる
    /// </summary>
    Task DropRouteRelayWithoutSwitchingMachineWhereLeverRelayIsDropped();
}

// 実装 (Repositories/Route/RouteRepository.cs)
public class RouteRepository(ApplicationDbContext context) : IRouteRepository
{
    public async Task<List<Models.Route>> GetByIdsWithState(List<ulong> ids)
    {
        return await context.Routes
            .Include(r => r.RouteState)
            .Where(r => ids.Contains(r.Id))
            .ToListAsync();
    }

    public async Task DropRouteRelayWithoutSwitchingMachineWhereLeverRelayIsDropped()
    {
        await context.RouteStates
            .Where(routeState =>
                routeState.IsLeverRelayRaised == RaiseDrop.Drop &&
                routeState.IsRouteRelayWithoutSwitchingMachineRaised == RaiseDrop.Raise
            )
            .ExecuteUpdateAsync(r =>
                r.SetProperty(routeState => routeState.IsRouteRelayWithoutSwitchingMachineRaised, RaiseDrop.Drop)
            );
    }
}
```

### 3.2 Unit of Work パターン

**目的:** トランザクション境界を明示的に管理する

**実装:**
- `ITransactionRepository` でトランザクション開始・コミット・ロールバック
- Serviceレイヤーでトランザクション境界を制御

**例:**
```csharp
// Services/RouteService.cs
public class RouteService(IRouteRepository routeRepository)
{
    public async Task<List<RouteData>> GetActiveRoutes()
    {
        // てこ反応リレーが扛上している進路を取得
        var routeIds = await routeRepository.GetIdsWhereRouteRelayWithoutSwitchingMachineIsRaised();
        var routes = await routeRepository.GetByIdsWithState(routeIds);
        return routes.Select(ToRouteData).ToList();
    }

    private static RouteData ToRouteData(Route route)
    {
        return new()
        {
            TcName = route.TcName,
            RouteType = route.RouteType,
            RouteState = new()
            {
                IsRouteRelayRaised = route.RouteState.IsRouteRelayRaised,
                IsLeverRelayRaised = route.RouteState.IsLeverRelayRaised
            }
        };
    }
}
```

### 3.3 Dependency Injection

**目的:** 依存関係を外部から注入し、疎結合を実現する

**実装:**
- `Program.cs` で全ての依存関係を登録
- Scoped lifetime（リクエストごと）でDbContext/Repository/Serviceを管理

**例:**
```csharp
// Program.cs での登録
builder.Services.AddDbContext<ApplicationDbContext>(options =>
    options.UseNpgsql(connectionString));

// Repository登録
builder.Services.AddScoped<IRouteRepository, RouteRepository>();
builder.Services.AddScoped<ISignalRepository, SignalRepository>();

// Service登録
builder.Services.AddScoped<RouteService>();
builder.Services.AddScoped<InterlockingService>();
```

### 3.4 SignalR Hub パターン

**目的:** リアルタイム双方向通信を実現する

**実装:**
- `TypedSignalR.Client` で型安全なコントラクト定義
- Hubメソッド内でServiceを呼び出し
- クライアント側にも同じコントラクトを共有

**例:**
```csharp
// Contract定義 (Common/Contract/IInterlockingHubContract.cs)
public interface IInterlockingHubContract
{
    Task<DataToInterlocking> SendData_Interlocking(List<string> activeStationsList);
    Task<InterlockingLeverData> SetPhysicalLeverData(InterlockingLeverData leverData);
    Task<InterlockingKeyLeverData> SetPhysicalKeyLeverData(InterlockingKeyLeverData keyLeverData);
    Task<DestinationButtonData> SetDestinationButtonState(DestinationButtonData buttonData);
}

public interface IInterlockingClientContract
{
    Task ReceiveData(DataToInterlocking data);
    Task ReceiveSignalData(List<SignalData> signalData);
}

// Hub実装 (Hubs/InterlockingHub.cs)
[Authorize(
    AuthenticationSchemes = OpenIddictValidationAspNetCoreDefaults.AuthenticationScheme,
    Policy = "InterlockingPolicy"
)]
public class InterlockingHub(InterlockingService interlockingService)
    : Hub<IInterlockingClientContract>, IInterlockingHubContract
{
    public async Task<DataToInterlocking> SendData_Interlocking(List<string> activeStationsList)
    {
        return await interlockingService.SendData_Interlocking();
    }

    public async Task<InterlockingLeverData> SetPhysicalLeverData(InterlockingLeverData leverData)
    {
        return await interlockingService.SetPhysicalLeverData(leverData);
    }
}
```

### 3.5 Scheduler パターン

**目的:** 定期的なバックグラウンド処理を実現する

**実装:**
- `Scheduler` 抽象基底クラスを継承して個別のSchedulerを実装
- 各Schedulerは一定間隔でタスクを実行
- SignalRクライアントへのデータプッシュなどに使用

**例:**
```csharp
// 基底クラス (Scheduler/Scheduler.cs)
public abstract class Scheduler
{
    private readonly IServiceScopeFactory _serviceScopeFactory;
    protected abstract int Interval { get; }

    protected Scheduler(IServiceScopeFactory serviceScopeFactory)
    {
        _serviceScopeFactory = serviceScopeFactory;
        _task = Task.Run(async () => await RunAsync(_cancellationTokenSource.Token));
    }

    private async Task RunAsync(CancellationToken cancellationToken)
    {
        while (!cancellationToken.IsCancellationRequested)
        {
            using var scope = _serviceScopeFactory.CreateScope();
            var timer = Task.Delay(Interval, cancellationToken);

            using (var activity = ActivitySources.Scheduler.StartActivity($"{GetType().Name}.ExecuteTask"))
            {
                try
                {
                    await ExecuteTaskAsync(scope, activity);
                }
                catch (Exception ex)
                {
                    logger.LogError(ex, "An error occurred while executing the task.");
                }
            }

            await timer;
        }
    }

    protected abstract Task ExecuteTaskAsync(IServiceScope scope, Activity? activity);
}

// 具体的なScheduler実装 (Scheduler/InterlockingHubScheduler.cs)
public class InterlockingHubScheduler(IServiceScopeFactory serviceScopeFactory)
    : Scheduler(serviceScopeFactory)
{
    protected override int Interval => 250;  // 250ms間隔で実行

    protected override async Task ExecuteTaskAsync(IServiceScope scope, Activity? activity)
    {
        var hubContext = scope.ServiceProvider
            .GetRequiredService<IHubContext<InterlockingHub, IInterlockingClientContract>>();
        var interlockingService = scope.ServiceProvider
            .GetRequiredService<InterlockingService>();

        // データ取得してクライアントに送信
        var data = await interlockingService.SendData_Interlocking();
        await hubContext.Clients.All.ReceiveData(data);
    }
}
```

**主要なScheduler:**
- `InterlockingHubScheduler`: 連動データの定期配信（250ms間隔）
- `TrainScheduler`: 列車データの定期配信
- `SignalScheduler`: 信号データの定期配信
- `SwitchingMachineScheduler`: 転てつ機データの定期配信

---

## 4. ドメインモデル設計

### 4.1 主要ドメイン

| ドメイン | 説明 | 主要エンティティ |
|---------|------|-----------------|
| **連動（Interlocking）** | 信号保安設備の連動制御 | `Route`, `Signal`, `SwitchingMachine`, `TrackCircuit`, `Lever` |
| **列車（Train）** | 列車運行管理 | `Train`, `TrainCar`, `TrainDiagram`, `TrainState` |
| **駅・停車場（Station）** | 停車場マスタ | `Station` |
| **TTC窓（TtcWindow）** | 列番窓管理 | `TtcWindow`, `TtcWindowLink` |
| **操作情報（OperationInformation）** | 操作履歴管理 | `OperationInformation` |

### 4.2 エンティティ設計原則

#### 4.2.1 主キー設計

- 各エンティティは主キー（Primary Key）を持つ
- 主キーの型は `ulong` を使用

#### 4.2.2 Enum 型の保存

- DB上EnumはPostgres Enumとして保存（`EnumTypeMapper.cs` で変換を定義する）

**例:**
```csharp
public enum RaiseDrop
{
    Drop,
    Raise
}

// データベースには "Raise" / "Drop" として保存
```

#### 4.2.3 リレーション設計

- Entity Framework Core の Navigation Property で表現
- `Include()` / `ThenInclude()` で明示的にロード

**例:**
```csharp
public class Route
{
    public ulong Id { get; set; }
    public string Name { get; set; } = string.Empty;

    // Navigation Properties
    public ulong SignalId { get; set; }
    public Signal Signal { get; set; } = null!;

    public RouteState RouteState { get; set; } = null!;
}
```

#### 4.2.4 State テーブル設計

**重要な設計思想:**

- **Stateテーブル**: 状態を持つオブジェクト（すなわち、運転会中に変化しうるもの）を管理
- 静的なマスタデータと動的な状態データを分離

**例:**

| エンティティ | State エンティティ | 説明 |
|-------------|-------------------|------|
| `Route` | `RouteState` | 進路の現在状態（てこリレー、進路リレー等） |
| `Lever` | `LeverState` | てこの現在位置（定位/反位） |
| `TrackCircuit` | `TrackCircuitState` | 軌道回路の励磁/非励磁状態 |
| `Signal` | - | 信号機マスタ（状態なし、静的データ） |

**設計メリット:**
- 静的データと動的データの責務分離

**実装例:**
```csharp
// 静的マスタデータ
public class Route
{
    public ulong Id { get; set; }
    public string Name { get; set; } = string.Empty;
    public ulong SignalId { get; set; }
    // ... 設定値（運転会中は変化しない）
}

// 動的状態データ（運転会中に変化）
public class RouteState
{
    public ulong RouteId { get; set; }
    public RaiseDrop IsLeverRelayRaised { get; set; }
    public RaiseDrop IsRouteRelayRaised { get; set; }
    // ... 状態値（運転会中に変化する）
}
```

---

## 5. データベース設計

### 5.1 使用技術

- **RDBMS**: PostgreSQL 16.4
- **ORM**: Entity Framework Core 8.0
- **マイグレーション**: Atlas CLI

### 5.2 スキーマ管理

- `Database/schema.sql`: 現在のスキーマ定義（手動編集）
- `Database/migrations/`: Atlas が自動生成したマイグレーションファイル
- マイグレーションファイルを手動編集した場合は、以下コマンドを実行すること。
```
atlas migrate hash
```

### 5.3 主要テーブル

| テーブル | 説明 |
|---------|------|
| `route` | 進路マスタ |
| `route_state` | 進路状態 |
| `signal` | 信号機マスタ |
| `switching_machine` | 転てつ機マスタ |
| `switching_machine_route` | 転てつ機進路関連 |
| `track_circuit` | 軌道回路マスタ |
| `track_circuit_state` | 軌道回路状態 |
| `lever` | てこマスタ |
| `lever_state` | てこ状態 |
| `train` | 列車マスタ |
| `train_state` | 列車状態 |
| `station` | 駅・停車場マスタ |
| `ttc_window` | TTC列番窓マスタ |

---

## 6. ディレクトリ構成

### 6.1 Traincrew_MultiATS_Server（コアライブラリ）

```
Traincrew_MultiATS_Server/
├── Activity/              # OpenTelemetry ActivitySources
├── Authentication/        # Discord認証処理
├── Constants/             # 定数定義
├── Data/
│   ├── ApplicationDbContext.cs    # EF Core DbContext
│   └── EnumTypeMapper.cs          # Enum型マッピング
├── Exception/             # カスタム例外
├── HostedService/         # バックグラウンドサービス
│   ├── DiscordBotHostedService.cs
│   └── InitDbHostedService.cs     # DB初期化サービス
├── Hubs/                  # SignalR Hubs
│   ├── CommanderTableHub.cs
│   ├── CTCPHub.cs
│   ├── InterlockingHub.cs
│   ├── TIDHub.cs
│   └── TrainHub.cs
├── Initialization/        # DB初期化オーケストレーション
├── Models/                # EF Core エンティティ（40個以上）
│   ├── Route.cs, RouteState.cs
│   ├── Signal.cs, SignalRoute.cs
│   ├── Lever.cs, LeverState.cs
│   └── ... (他多数)
├── Repositories/          # リポジトリ（35個以上）
│   ├── Route/
│   │   ├── IRouteRepository.cs
│   │   └── RouteRepository.cs
│   ├── Signal/
│   ├── TrackCircuit/
│   └── ... (他多数)
├── Scheduler/             # スケジューリング
├── Services/              # ビジネスロジック（20個以上）
│   ├── RouteService.cs
│   ├── InterlockingService.cs
│   ├── TrainService.cs
│   └── ... (他多数)
└── Traincrew_MultiATS_Server.csproj
```

### 6.2 Traincrew_MultiATS_Server.Crew（乗務員サーバー）

```
Traincrew_MultiATS_Server.Crew/
├── Controllers/           # HTTP APIコントローラー
├── Data/
│   └── RendoTable/       # 蓮土テーブル初期化用CSVファイル
│       ├── TTC列番窓.csv
│       ├── 駅・停車場.csv
│       ├── 進路.csv
│       └── ... (他多数)
├── appsettings.json
├── appsettings.Development.json
└── Program.cs            # 依存性注入設定、SignalR設定
```

### 6.3 Traincrew_MultiATS_Server.Common（共通スキーマ）

```
Traincrew_MultiATS_Server.Common/
├── Contract/              # SignalRコントラクト
│   ├── ICommanderTableHubContract.cs
│   ├── ICTCPHubContract.cs
│   ├── IInterlockingHubContract.cs
│   ├── ITIDHubContract.cs
│   └── ITrainHubContract.cs
├── Models/                # 共有Body
│   ├── ATS.cs
│   ├── Interlocking.cs
│   ├── TID.cs
│   └── ... (他多数)
└── Traincrew_MultiATS_Server.Common.csproj
```

---

## 7. アーキテクチャ上の決定事項

### 7.1 なぜ Repository パターンを採用したか

**理由:**
1. **テスタビリティ**: Repositoryをモック化して、Serviceレイヤーを単独でテスト可能
2. **関心の分離**: データアクセスロジックとビジネスロジックを分離する
   - データアクセスロジックを変更しても、ビジネスロジックに影響を与えない
   - 特に、裏で動くDBサーバーを変更したり(MySQLにするとか)、使うライブラリを変更した時(EF Core -> Dapperとか)に有効
3. **保守性**: クエリロジックをRepository内に集約し、変更の影響範囲を限定

### 7.2 なぜ State テーブルを分離したか

**理由:**
1. **責務の明確化**: 静的マスタ（設定値）と動的状態を分離

### 7.3 なぜ SignalR を採用したか

**理由:**
1. **リアルタイム性**: 進路開通、信号現示変化等をリアルタイムに全クライアントへ配信
2. **双方向通信**: クライアントからのイベント受信とサーバーからのプッシュ通知を統一
3. **型安全性**: TypedSignalR.Client でコンパイル時に型チェック可能

---

## 8. 次のステップ

アーキテクチャ設計を理解したら、以下のドキュメントを参照してください：

- **05_テスト戦略.md**: テストの書き方と実行方法
