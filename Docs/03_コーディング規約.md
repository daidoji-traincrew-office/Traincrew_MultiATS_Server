# 03_コーディング規約

## 概要

このドキュメントでは、Traincrew_MultiATS_Server プロジェクトで採用しているコーディング規約、ベストプラクティス、禁止事項を説明します。

---

## 1. 命名規則

### 1.1 基本ルール

| 対象 | ルール | 例 |
|------|-------|---|
| **クラス** | PascalCase | `RouteService`, `ApplicationDbContext` |
| **インターフェース** | PascalCase + `I` プレフィックス | `IRouteRepository`, `ITransactionRepository` |
| **メソッド** | PascalCase | `GetRouteById`, `SetRoute` |
| **プロパティ** | PascalCase | `RouteId`, `IsLeverRelayRaised` |
| **プライベートフィールド** | `_camelCase` | `_routeRepository`, `_context` |
| **ローカル変数** | camelCase | `routeId`, `signalAspect` |
| **定数** | PascalCase | `MaxRetryCount`, `DefaultTimeout` |
| **列挙型（Enum）** | PascalCase | `RaiseDrop`, `RouteType` |
| **列挙値** | PascalCase | `Raise`, `Drop` |

### 1.2 特定パターンの命名

| パターン | 命名ルール | 例 |
|---------|----------|---|
| **Repository** | `I{Entity}Repository` / `{Entity}Repository` | `IRouteRepository`, `RouteRepository` |
| **Service** | `{Domain}Service` | `RouteService`, `InterlockingService` |
| **Hub** | `{Domain}Hub` | `InterlockingHub`, `TrainHub` |
| **Contract** | `I{Domain}HubContract` | `IInterlockingHubContract` |
| **State エンティティ** | `{Entity}State` | `RouteState`, `LeverState` |

### 1.3 コレクション・辞書の命名規則

| パターン | 命名ルール | 例 |
|---------|----------|---|
| **単一エンティティ** | `T` (複数形にしない) | `route`, `lever`, `signal` |
| **List<T>** | `Ts` (複数形にする) | `routes`, `levers`, `signals` |
| **Dictionary<TKey, TValue>** | `TValueByTKey` | `routeById`, `leverByName`, `signalByTrackCircuitId` |
| **Dictionary<TKey, List<TValue>>** | `TValuesByTKey` | `routesBySignalId`, `leversByType`, `trainCarsByTrainId` |

#### コレクション命名の例

```csharp
// ✅ Good: 単一エンティティ
var route = await routeRepository.GetById(routeId);
var lever = await leverRepository.GetByName(leverName);

// ✅ Good: List<T> は複数形
var routes = await routeRepository.GetAll();
var levers = await leverRepository.GetByType(LeverType.Route);
var signals = await signalRepository.GetByTrackCircuitId(trackCircuitId);

// ✅ Good: Dictionary<TKey, TValue> は TValueByTKey
var routeById = routes.ToDictionary(r => r.Id);
var leverByName = levers.ToDictionary(l => l.Name);
var signalByTrackCircuitId = signals.ToDictionary(s => s.TrackCircuitId);

// ✅ Good: Dictionary<TKey, List<TValue>> は TValuesByTKey
var routesBySignalId = routes
    .GroupBy(r => r.SignalId)
    .ToDictionary(g => g.Key, g => g.ToList());
var leversByType = levers
    .GroupBy(l => l.Type)
    .ToDictionary(g => g.Key, g => g.ToList());

// ❌ Bad: ListやDictのような単語を変数名に使う
var routeList = await routeRepository.GetAll();  // "routes" とすべき
var lever_collection = levers.ToList();  // "levers" で十分
var routeDict = routes.ToDictionary(r => r.Id);  // "routeById" とすべき
var routeMap = routes.GroupBy(r => r.SignalId)
    .ToDictionary(g => g.Key, g => g.ToList());  // "routesBySignalId" とすべき
```

---

## 2. 非同期プログラミング

### 2.1 基本ルール

- 非同期メソッドは `async Task` または `async Task<T>` で定義
- `await` キーワードを使用してデッドロックを回避
- `.Result` / `.Wait()` の使用は禁止（デッドロックリスク）

### 2.2 良い例 / 悪い例

```csharp
// ✅ Good
public async Task<Route?> GetRouteById(ulong routeId)
{
    return await _context.Routes.FindAsync(routeId);
}

// ❌ Bad: .Result 使用（デッドロック発生リスク）
public Route? GetRouteById(ulong routeId)
{
    return _context.Routes.FindAsync(routeId).Result;
}

// ❌ Bad: .Wait() 使用
public void SetRoute(ulong routeId)
{
    SetRouteAsync(routeId).Wait();
}
```

### 2.3 ConfigureAwait について

- ASP.NET Core では基本的に `ConfigureAwait(false)` は不要
- SynchronizationContext が存在しないため、デフォルトで安全

---

## 3. 宣言的なコードを書く

### 3.1 基本原則

- 可能な限り、**宣言的（Declarative）** なコードを書く
- LINQメソッドチェーンを活用し、「何を」するかを明確に表現
- 命令的（Imperative）なループよりも、集約や射影を明示的に記述

### 3.2 良い例 / 悪い例

```csharp
// ✅ Good: 宣言的
var raisedRouteIds = routes 
    .Where(r => r.RouteState.IsLeverRelayRaised == RaiseDrop.Raise)
    .Select(r => r.Id)
    .ToList();

// ❌ Bad: 命令的
var raisedRouteIds = new List<ulong>();
foreach (var route in routes)
{
    if (route.RouteState.IsLeverRelayRaised == RaiseDrop.Raise)
    {
        raisedRouteIds.Add(route.Id);
    }
}
```

```csharp
// ✅ Good: LINQで集約
var totalCars = trains
    .SelectMany(t => t.TrainCars)
    .Count();

// ❌ Bad: ループで集約
var totalCars = 0;
foreach (var train in trains)
{
    foreach (var car in train.TrainCars)
    {
        totalCars++;
    }
}
```

```csharp
// ✅ Good: 変換をSelect/ToDictionaryで明示
var routeDict = routes
    .ToDictionary(r => r.Id, r => r.Name);

// ❌ Bad: ループで辞書構築
var routeDict = new Dictionary<ulong, string>();
foreach (var route in routes)
{
    routeDict[route.Id] = route.Name;
}
```

---

## 5. Repository/Service 実装ルール

### 5.1 Repository の責務

- 1エンティティ = 1Repository
- CRUDメソッド、検索メソッドを定義
- クエリロジックをServiceに漏らさない
- **Repository のみが DbContext にアクセス可能**

### 5.2 ExecuteUpdate/ExecuteDelete の使用

**特定条件に基づいた一括更新・削除には、`ExecuteUpdateAsync` / `ExecuteDeleteAsync` を使用すること**

- SELECT → UPDATE/DELETE の2往復を避け、1クエリで完結
- パフォーマンス向上とトランザクション整合性の確保
- EF Core 7.0 以降で利用可能

#### 一括更新の例

```csharp
// ✅ Good: ExecuteUpdateAsync で一括更新 (Repositories/OperationNotification/OperationNotificationRepository.cs)
public async Task SetNoneWhereKaijoOrTorikeshiAndOperatedBeforeOrEqual(DateTime operatedAt)
{
    await context.OperationNotificationStates
        .Where(s =>
            (s.Type == OperationNotificationType.Kaijo || s.Type == OperationNotificationType.Torikeshi)
            && s.OperatedAt <= operatedAt)
        .ExecuteUpdateAsync(s => s
            .SetProperty(ons => ons.Type, OperationNotificationType.None)
            .SetProperty(ons => ons.Content, string.Empty)
        );
}

// ❌ Bad: SELECT → UPDATE の2往復
public async Task SetNoneWhereKaijoOrTorikeshiAndOperatedBeforeOrEqual(DateTime operatedAt)
{
    var states = await context.OperationNotificationStates
        .Where(s =>
            (s.Type == OperationNotificationType.Kaijo || s.Type == OperationNotificationType.Torikeshi)
            && s.OperatedAt <= operatedAt)
        .ToListAsync();

    foreach (var state in states)
    {
        state.Type = OperationNotificationType.None;
        state.Content = string.Empty;
    }
    await context.SaveChangesAsync();
}
```

#### 一括削除の例

```csharp
// ✅ Good: ExecuteDeleteAsync で一括削除 (Repositories/TrainCar/TrainCarRepository.cs)
public async Task DeleteByTrainId(long trainId)
{
    await context.TrainCarStates
        .Where(car => car.TrainStateId == trainId)
        .ExecuteDeleteAsync();
}

// ❌ Bad: SELECT → DELETE の2往復
public async Task DeleteByTrainId(long trainId)
{
    var trainCars = await context.TrainCarStates
        .Where(car => car.TrainStateId == trainId)
        .ToListAsync();
    context.TrainCarStates.RemoveRange(trainCars);
    await context.SaveChangesAsync();
}
```

#### ExecuteUpdate/ExecuteDelete を使うべきでないケース

以下のケースでは `GeneralRepository` を使用してエンティティを取得→更新→保存するパターンを使います：

**1. 更新前の値を取得する必要がある場合**

```csharp
// ✅ Good: GeneralRepositoryを使用 (Services/InterlockingService.cs)
public async Task<InterlockingLeverData> SetPhysicalLeverData(InterlockingLeverData leverData)
{
    var lever = await leverRepository.GetLeverByNameWithState(leverData.Name);
    if (lever == null)
    {
        throw new ArgumentException("Invalid lever name");
    }

    // 更新前の値を取得してログ出力
    var oldState = lever.LeverState.IsReversed;
    lever.LeverState.IsReversed = leverData.State;

    if (oldState != leverData.State)
    {
        logger.LogInformation("Lever {LeverName} state changed: {OldState} -> {NewState}",
            leverData.Name, oldState, leverData.State);
    }

    await generalRepository.Save(lever.LeverState);
    return ToLeverData(lever);
}

// ❌ Bad: ExecuteUpdateでは更新前の値が取得できない
public async Task SetPhysicalLeverData(InterlockingLeverData leverData)
{
    // 更新前の値を記録できない！
    await context.LeverStates
        .Where(ls => ls.Name == leverData.Name)
        .ExecuteUpdateAsync(ls =>
            ls.SetProperty(l => l.IsReversed, leverData.State)
        );
}
```

**2. 複雑なビジネスロジックを含む場合**

```csharp
// ✅ Good: エンティティを取得してロジック実行
public async Task UpdateTrainPosition(ulong trainId, Position newPosition)
{
    var train = await trainRepository.GetByIdWithState(trainId);

    // 複雑なビジネスロジック
    if (train.TrainState.CurrentPosition.IsNearStation())
    {
        train.TrainState.Speed = CalculateApproachSpeed(train);
    }

    train.TrainState.CurrentPosition = newPosition;
    train.TrainState.LastUpdated = DateTime.UtcNow;

    await generalRepository.Save(train.TrainState);
}
```

**3. 単一エンティティの更新の場合**

```csharp
// ✅ Good: 単一エンティティはGeneralRepositoryで十分
public async Task UpdateLeverState(ulong leverId, LCR newState)
{
    var lever = await leverRepository.GetByIdWithState(leverId);
    lever.LeverState.IsReversed = newState;
    await generalRepository.Save(lever.LeverState);
}

// ❌ Overkill: 単一エンティティにExecuteUpdateは過剰
public async Task UpdateLeverState(ulong leverId, LCR newState)
{
    await context.LeverStates
        .Where(ls => ls.LeverId == leverId)
        .ExecuteUpdateAsync(ls => ls.SetProperty(l => l.IsReversed, newState));
}
```

**まとめ:**
- **ExecuteUpdate/ExecuteDelete**: 条件に基づく一括更新・削除に最適
- **GeneralRepository**: 単一エンティティ、更新前後の値が必要、複雑なロジックを含む場合

### 5.3 Service の責務

- 複雑なビジネスロジックを実装
- 複数Repositoryを組み合わせる
- トランザクション管理
- Hubから呼び出される
- **❌ DbContext を直接利用してはいけない** - 必ずRepository経由でアクセス

```csharp
// ✅ Good: Service層でRepositoryを利用
public class RouteService(IRouteRepository routeRepository)
{
    public async Task<List<RouteData>> GetActiveRoutes()
    {
        // Repositoryを通じてデータアクセス
        var routeIds = await routeRepository.GetIdsWhereRouteRelayWithoutSwitchingMachineIsRaised();
        var routes = await routeRepository.GetByIdsWithState(routeIds);
        return routes.Select(ToRouteData).ToList();
    }

    private static RouteData ToRouteData(Route route)
    {
        return new()
        {
            TcName = route.TcName,
            RouteType = route.RouteType,
            RouteState = new()
            {
                IsLeverRelayRaised = route.RouteState.IsLeverRelayRaised,
                IsRouteRelayRaised = route.RouteState.IsRouteRelayRaised
            }
        };
    }
}

// ❌ Bad: ServiceでDbContextを直接利用
public class RouteService(ApplicationDbContext context)
{
    public async Task<List<RouteData>> GetActiveRoutes()
    {
        // DbContextを直接使用するのはNG!
        var routes = await context.Routes
            .Include(r => r.RouteState)
            .Where(r => r.RouteState.IsRouteRelayRaised == RaiseDrop.Raise)
            .ToListAsync();
        // ...
    }
}
```

## 7. ログ出力

### 7.1 基本ルール

- `ILogger<T>` を使用
- ログレベルを適切に設定（Debug, Information, Warning, Error, Critical）
- センシティブ情報（パスワード、トークン）をログに出力しない
- 構造化ログを活用（プレースホルダー使用）

### 7.2 良い例 / 悪い例

```csharp
// ✅ Good: 構造化ログ
_logger.LogInformation("Route {RouteId} has been set successfully", routeId);
_logger.LogError(ex, "Failed to set route {RouteId}", routeId);

// ❌ Bad: 文字列結合
_logger.LogInformation("Route " + routeId + " has been set successfully");

// ❌ Bad: センシティブ情報を出力
_logger.LogInformation("User password: {Password}", password);  // NG!
```

### 7.3 ログレベルの使い分け

| レベル | 用途 | 例 |
|--------|------|---|
| `Trace` | 最も詳細なデバッグ情報 | メソッド呼び出しトレース |
| `Debug` | 開発時のデバッグ情報 | クエリ実行内容、変数値 |
| `Information` | 一般的な情報 | リクエスト受信、処理完了 |
| `Warning` | 警告（処理は継続） | リトライ発生、予期しないデータ |
| `Error` | エラー（処理失敗） | 例外発生、処理失敗 |
| `Critical` | クリティカルエラー | システム停止レベルの障害 |

---

## 8. データベースマイグレーション

### 8.1 基本フロー

1. `schema.sql` を手動編集
2. `atlas migrate diff` でマイグレーション生成
3. `atlas migrate apply` で適用

### 8.2 ルール

- ✅ `schema.sql` のみを編集し、Atlasに自動生成させる
- ✅ マイグレーション名は意味のある名前を付ける

```bash
# ✅ Good: 意味のある名前
atlas migrate diff --env local add_train_signal_state_table

# ❌ Bad: 意味不明な名前
atlas migrate diff --env local update
```

---

## 9. テストコード

### 9.1 テスト戦略

| テスト種別 | プロジェクト | 対象 |
|-----------|------------|------|
| **統合テスト（IT）** | `Traincrew_MultiATS_Server.IT` | Hubエンドポイント、Controllerエンドポイント、複数層にまたがるロジック |
| **ユニットテスト（UT）** | `Traincrew_MultiATS_Server.UT` | 独立したロジック、ホストサービス |

### 9.2 テスト命名規則

```csharp
// ✅ Good: メソッド名でテスト内容が理解できる
[Fact]
public async Task SetRoute_WhenRouteExists_ShouldReturnSuccess()
{
    // Arrange
    var routeId = 1UL;
    // Act
    var result = await _routeService.SetRoute(routeId);
    // Assert
    Assert.True(result.IsSuccess);
}

// ❌ Bad: 意味不明なテスト名
[Fact]
public async Task Test1()
{
    // ...
}
```

### 9.3 AAA パターン

- **Arrange**: テスト準備
- **Act**: テスト実行
- **Assert**: 検証

```csharp
[Fact]
public async Task GetRouteById_WhenRouteNotFound_ShouldReturnNull()
{
    // Arrange
    var nonExistentRouteId = 99999UL;

    // Act
    var route = await _routeRepository.GetById(nonExistentRouteId);

    // Assert
    Assert.Null(route);
}
```

---

## 10. コード整形

### 10.1 EditorConfig

- プロジェクトルートに `.editorconfig` を配置
- インデント: 4スペース
- 改行コード: CRLF

---

## 11. 禁止事項

### 11.1 アーキテクチャ違反

- ❌ DbContextをController/Hubで直接利用
- ❌ DbContextをServiceで直接利用
- ❌ Service層をスキップしてRepositoryを直接Hubから呼ぶ

### 11.2 データベース関連

- ❌ マイグレーションファイルを手動編集
- ❌ `appsettings.json` に秘匿情報（パスワード、APIキー）をコミット
  - 代わりに環境変数または User Secrets を使用

### 11.3 非同期処理

- ❌ 非同期メソッドで `.Result` / `.Wait()` 使用（デッドロックリスク）
- ❌ `async void` メソッド（例外がキャッチできない）
  - `async Task` を使用すること

### 11.4 パフォーマンス

- ❌ 一括更新・削除でSELECT → UPDATE/DELETE パターン
  - `ExecuteUpdateAsync` / `ExecuteDeleteAsync` を使用すること
- ❌ 取得時のN+1問題が発生するコードの禁止

**N+1問題の例:**

```csharp
// ❌ Bad: N+1問題 - ループ内でクエリを発行
public async Task<List<RouteData>> GetRoutesWithSignals()
{
    var routes = await context.Routes.ToListAsync();  // 1回のクエリ
    var result = new List<RouteData>();

    foreach (var route in routes)  // N回のループ
    {
        // 各ループでクエリが発行される = N+1問題!
        var signal = await context.Signals.FindAsync(route.SignalId);
        result.Add(new RouteData
        {
            RouteName = route.Name,
            SignalName = signal?.Name
        });
    }
    return result;
}

// ✅ Good: Include で事前ロード
public async Task<List<RouteData>> GetRoutesWithSignals()
{
    var routes = await context.Routes
        .Include(r => r.Signal)  // 関連エンティティを1回のクエリで取得
        .ToListAsync();

    return routes.Select(route => new RouteData
    {
        RouteName = route.Name,
        SignalName = route.Signal?.Name
    }).ToList();
}

// ✅ Good: IDリストで一括取得
public async Task<List<RouteData>> GetRoutesWithSignals()
{
    var routes = await context.Routes.ToListAsync();
    var signalIds = routes.Select(r => r.SignalId).ToList();

    // IDリストで一度に全Signal を取得
    var signals = await context.Signals
        .Where(s => signalIds.Contains(s.Id))
        .ToListAsync();

    var signalDict = signals.ToDictionary(s => s.Id);

    return routes.Select(route => new RouteData
    {
        RouteName = route.Name,
        SignalName = signalDict.GetValueOrDefault(route.SignalId)?.Name
    }).ToList();
}
```

---

## 12. 推奨プラクティス

### 12.1 using ディレクティブ

- ファイルスコープ using を推奨（C# 10）

```csharp
// ✅ Good: ファイルスコープ
using Traincrew_MultiATS_Server.Models;
using Traincrew_MultiATS_Server.Repositories;

namespace Traincrew_MultiATS_Server.Services;

public class RouteService
{
    // ...
}
```

### 12.2 var の使用

- 型が明らかな場合は `var` を使用
- 型が不明瞭な場合は明示的に型を記述

- 一般に`var`を使用し、コンパイルエラーが発生した場合は明示的に書く

```csharp
// ✅ Good: 型が明らか
var route = new Route();
var routes = await _context.Routes.ToListAsync();
```

## 13. まとめ

このコーディング規約は、以下を目的としています：

1. **一貫性**: チーム全体で統一されたコードスタイル
2. **可読性**: 他の開発者が理解しやすいコード
3. **保守性**: 変更に強く、拡張しやすいコード
4. **品質**: バグが少なく、パフォーマンスの良いコード

規約を守ることで、長期的なプロジェクトの成功に貢献できます。

---

## 14. 次のステップ

- **04_アーキテクチャ設計.md**: プロジェクト全体のアーキテクチャを理解
- **05_テスト戦略.md**: テストの書き方と実行方法
