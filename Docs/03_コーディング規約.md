# 03_コーディング規約

## 概要

このドキュメントでは、Traincrew_MultiATS_Server プロジェクトで採用しているコーディング規約、ベストプラクティス、禁止事項を説明します。

---

## 1. 命名規則

### 1.1 基本ルール

| 対象 | ルール | 例 |
|------|-------|---|
| **クラス** | PascalCase | `RouteService`, `ApplicationDbContext` |
| **インターフェース** | PascalCase + `I` プレフィックス | `IRouteRepository`, `ITransactionRepository` |
| **メソッド** | PascalCase | `GetRouteById`, `SetRoute` |
| **プロパティ** | PascalCase | `RouteId`, `IsLeverRelayRaised` |
| **プライベートフィールド** | `_camelCase` | `_routeRepository`, `_context` |
| **ローカル変数** | camelCase | `routeId`, `signalAspect` |
| **定数** | PascalCase | `MaxRetryCount`, `DefaultTimeout` |
| **列挙型（Enum）** | PascalCase | `RaiseDrop`, `RouteType` |
| **列挙値** | PascalCase | `Raise`, `Drop` |

### 1.2 特定パターンの命名

| パターン | 命名ルール | 例 |
|---------|----------|---|
| **Repository** | `I{Entity}Repository` / `{Entity}Repository` | `IRouteRepository`, `RouteRepository` |
| **Service** | `{Domain}Service` | `RouteService`, `InterlockingService` |
| **Hub** | `{Domain}Hub` | `InterlockingHub`, `TrainHub` |
| **Contract** | `I{Domain}HubContract` | `IInterlockingHubContract` |
| **State エンティティ** | `{Entity}State` | `RouteState`, `LeverState` |

### 1.3 コレクション・辞書の命名規則

| パターン | 命名ルール | 例 |
|---------|----------|---|
| **単一エンティティ** | `T` (複数形にしない) | `route`, `lever`, `signal` |
| **List<T>** | `Ts` (複数形にする) | `routes`, `levers`, `signals` |
| **Dictionary<TKey, TValue>** | `TValueByTKey` | `routeById`, `leverByName`, `signalByTrackCircuitId` |
| **Dictionary<TKey, List<TValue>>** | `TValuesByTKey` | `routesBySignalId`, `leversByType`, `trainCarsByTrainId` |

#### コレクション命名の例

```csharp
// ✅ Good: 単一エンティティ
var route = await routeRepository.GetById(routeId);
var lever = await leverRepository.GetByName(leverName);

// ✅ Good: List<T> は複数形
var routes = await routeRepository.GetAll();
var levers = await leverRepository.GetByType(LeverType.Route);
var signals = await signalRepository.GetByTrackCircuitId(trackCircuitId);

// ✅ Good: Dictionary<TKey, TValue> は TValueByTKey
var routeById = routes.ToDictionary(r => r.Id);
var leverByName = levers.ToDictionary(l => l.Name);
var signalByTrackCircuitId = signals.ToDictionary(s => s.TrackCircuitId);

// ✅ Good: Dictionary<TKey, List<TValue>> は TValuesByTKey
var routesBySignalId = routes
    .GroupBy(r => r.SignalId)
    .ToDictionary(g => g.Key, g => g.ToList());
var leversByType = levers
    .GroupBy(l => l.Type)
    .ToDictionary(g => g.Key, g => g.ToList());

// ❌ Bad: ListやDictのような単語を変数名に使う
var routeList = await routeRepository.GetAll();  // "routes" とすべき
var lever_collection = levers.ToList();  // "levers" で十分
var routeDict = routes.ToDictionary(r => r.Id);  // "routeById" とすべき
var routeMap = routes.GroupBy(r => r.SignalId)
    .ToDictionary(g => g.Key, g => g.ToList());  // "routesBySignalId" とすべき
```

---

## 2. 非同期プログラミング

### 2.1 基本ルール

- 非同期メソッドは `async Task` または `async Task<T>` で定義
- `await` キーワードを使用してデッドロックを回避
- `.Result` / `.Wait()` の使用は禁止（デッドロックリスク）

### 2.2 良い例 / 悪い例

```csharp
// ✅ Good
public async Task<Route?> GetRouteById(ulong routeId)
{
    return await _context.Routes.FindAsync(routeId);
}

// ❌ Bad: .Result 使用（デッドロック発生リスク）
public Route? GetRouteById(ulong routeId)
{
    return _context.Routes.FindAsync(routeId).Result;
}

// ❌ Bad: .Wait() 使用
public void SetRoute(ulong routeId)
{
    SetRouteAsync(routeId).Wait();
}
```

### 2.3 ConfigureAwait について

- ASP.NET Core では基本的に `ConfigureAwait(false)` は不要
- SynchronizationContext が存在しないため、デフォルトで安全

---

## 3. 宣言的なコードを書く

### 3.1 基本原則

- 可能な限り、**宣言的（Declarative）** なコードを書く
- LINQメソッドチェーンを活用し、「何を」するかを明確に表現
- 命令的（Imperative）なループよりも、集約や射影を明示的に記述

### 3.2 良い例 / 悪い例

```csharp
// ✅ Good: 宣言的
var raisedRouteIds = routes
    .Where(r => r.RouteState.IsLeverRelayRaised == RaiseDrop.Raise)
    .Select(r => r.Id)
    .ToList();

// ❌ Bad: 命令的
var raisedRouteIds = new List<ulong>();
foreach (var route in routes)
{
    if (route.RouteState.IsLeverRelayRaised == RaiseDrop.Raise)
    {
        raisedRouteIds.Add(route.Id);
    }
}
```

```csharp
// ✅ Good: LINQで集約
var sourceOtherRoutes = sourceLevers
    .SelectMany(lever => routesByLeverId[lever.Id])
    .Where(r => sourceThrowOutRoutes.All(s => s.Id != r.Id))
    .ToList();

// ❌ Bad: ループで集約
var sourceOtherRoutes = new List<Route>();
foreach (var lever in sourceLevers)
{
    foreach (var route in routesByLeverId[lever.Id])
    {
        if (sourceThrowOutRoutes.All(s => s.Id != route.Id))
        {
            sourceOtherRoutes.Add(route);
        }
    }
}
```

```csharp
// ✅ Good: 変換をSelect/ToDictionaryで明示
var routeDict = routes
    .ToDictionary(r => r.Id, r => r.Name);

// ❌ Bad: ループで辞書構築
var routeDict = new Dictionary<ulong, string>();
foreach (var route in routes)
{
    routeDict[route.Id] = route.Name;
}
```

---

## 4. オブジェクト初期化とコレクション

### 4.1 コレクションリテラルの使用

**C# 12 以降では、コレクション初期化に `[]` リテラルを使用すること**

- `new List<T>()`, `new Dictionary<TKey, TValue>()` の使用は避ける
- 特定の実装型が必要な場合のみ例外とする

#### 基本的な使用例

```csharp
// ✅ Good: コレクションリテラルを使用
var routes = [route1, route2, route3];

// ✅ Good: 空のコレクション
var emptyList = [];  // 型は文脈から推論される

// ✅ Good: 明示的な型指定が必要な場合
List<Route> routes = [];

// ✅ Good: 戻り値の型から推論
public List<Route> GetActiveRoutes()
{
    return [];  // List<Route>と推論される
}

// ✅ Good: LINQと組み合わせ
var activeRoutes = routes
    .Where(r => r.IsActive)
    .ToList();  // ToList()は引き続き使用

// ❌ Bad: 旧スタイルのList初期化
var routes = new List<Route>();
var routes = new List<Route> { route1, route2 };
List<Route> routes = new();

// ❌ Bad: 明示的な型が不要な場合
var routes = new List<Route> { route1, route2, route3 };
```

#### 例外: 特定の実装型が必要な場合

```csharp
// ✅ Good: LinkedList, HashSet, Queue など特定の実装が必要な場合
var uniqueIds = new HashSet<ulong>();
var processingQueue = new Queue<Route>();
var linkedRoutes = new LinkedList<Route>();

// ✅ Good: 特定のコレクション型を要求するメソッドを呼ぶ場合
public void ProcessRoutes(HashSet<ulong> routeIds)
{
    // ...
}
var routeIds = new HashSet<ulong> { 1, 2, 3 };
ProcessRoutes(routeIds);
```

### 4.2 型推論の使用（Target-typed new）

**`new` 式で型が推論可能な場合は、型名を省略すること（C# 9+）**

- 代入先、戻り値、パラメータから型が明らかな場合は `new()` を使用
- 型が推論できない場合のみ明示的に型を記述

#### 良い例 / 悪い例

```csharp
// ✅ Good: 型推論を使用
Route route = new();
RouteData data = new() { Id = 1, Name = "R1" };

// ✅ Good: 戻り値の型から推論
public RouteData GetRouteData()
{
    return new() { Id = 1, Name = "R1" };
}

// ✅ Good: パラメータの型から推論
public void SetRoute(Route route) { }
SetRoute(new() { Id = 1 });

// ✅ Good: varを使う場合は型を明示
var route = new Route();
var data = new RouteData { Id = 1 };

// ❌ Bad: 型が推論可能なのに明示
Route route = new Route();
RouteData data = new RouteData() { Id = 1 };
return new RouteData { Id = 1 };

// ❌ Bad: varで型推論なしのnew()は使えない
var route = new();  // コンパイルエラー
```

### 4.3 組み合わせの例

両方のルールを組み合わせた実用例:

```csharp
// ✅ Good: コレクションリテラル + 型推論
public List<Route> GetActiveRoutes()
{
    Route route1 = new() { Id = 1, Name = "R1" };
    Route route2 = new() { Id = 2, Name = "R2" };
    return [route1, route2];
}

// ✅ Good: 空のコレクションを返す
public List<Route> FilterRoutes(List<Route> routes)
{
    if (routes.Count == 0)
        return [];

    // フィルタ処理
    return routes.Where(r => r.IsActive).ToList();
}

// ✅ Good: Repository実装例
public async Task<List<RouteData>> GetRoutesByIds(List<ulong> ids)
{
    if (ids.Count == 0)
        return [];

    var routes = await context.Routes
        .Where(r => ids.Contains(r.Id))
        .ToListAsync();

    return routes.Select(r => new RouteData
    {
        Id = r.Id,
        Name = r.Name,
        State = new() { IsActive = r.State.IsActive }
    }).ToList();
}

// ❌ Bad: 旧スタイル
public List<Route> GetActiveRoutes()
{
    var route1 = new Route() { Id = 1, Name = "R1" };
    var route2 = new Route() { Id = 2, Name = "R2" };
    return new List<Route> { route1, route2 };
}

// ❌ Bad: 不要な型の明示
public List<Route> FilterRoutes(List<Route> routes)
{
    if (routes.Count == 0)
        return new List<Route>();  // [] を使うべき

    return new List<Route>(routes.Where(r => r.IsActive));  // ToList() を使うべき
}
```

#### 注意事項

- **C# バージョン要件**: コレクションリテラル `[]` は C# 12 以降で使用可能（.NET 8+）
- **既存コード**: 既存の `new List<T>()` を見つけた場合は、順次 `[]` に置き換えること
- **パフォーマンス**: コレクションリテラルはコンパイラによって最適化されるため、パフォーマンス上の利点もある

---

## 5. Repository/Service 実装ルール

### 5.1 Repository の責務

- 1エンティティ = 1Repository
- CRUDメソッド、検索メソッドを定義
- クエリロジックをServiceに漏らさない
- **Repository のみが DbContext にアクセス可能**

### 5.1.1 Repository メソッドの命名規則

Repositoryメソッドは、取得するデータの種類によって命名パターンを使い分けます。

#### **1. Entity本体を取得する場合**

エンティティオブジェクト全体を取得する場合は、**`GetByXXX`** または **`GetAll`** を使用します。

| パターン         | 命名ルール | 例 |
|--------------|----------|---|
| **単数識別子で取得** | `GetByXXX` | `GetById`, `GetByName` |
| **複数識別子で取得** | `GetByXXXs` | `GetByIds`, `GetByStationIds` |
| **全件取得**     | `GetAll` | `GetAll` |
| **条件付き複数取得** | `GetWhereXXX` | `GetWhereApproachLockMSRelayIsRaised` |

```csharp
// ✅ Good: Entity本体を取得
Task<Route?> GetById(ulong id);
Task<List<Route>> GetByIds(List<ulong> ids);
Task<List<Route>> GetByTcNameWithState(string tcName);
Task<List<Route>> GetWhereApproachLockMSRelayIsRaised();

// ❌ Bad: Entity名を含めない
Task<Route?> GetRouteById(ulong id);  // "Route"は不要
Task<List<Route>> GetRoutesById(List<ulong> ids);  // "Routes"は不要
Task<List<Route>> GetRoutesByStationIds(List<string> stationIds);  // "Routes"は不要
```

#### **2. Entity の特定プロパティを取得する場合**

エンティティの特定のプロパティ（IDや名前など）のみを取得する場合は、**`Get{PropertyName}ByXXX`** を使用します。

| パターン | 命名ルール | 例 |
|---------|----------|---|
| **特定プロパティ取得** | `Get{Property}ByXXX` | `GetNameById` |
| **複数プロパティ取得** | `Get{Property}sByXXX` | `GetIdsByStationId`, `GetNamesByType` |
| **条件付きプロパティ取得** | `Get{Property}sWhereXXX` | `GetIdsWhereLeverRelayIsRaised` |

```csharp
// ✅ Good: プロパティのみを取得
Task<List<ulong>> GetIdsWhereLeverRelayIsRaised();
Task<List<ulong>> GetIdsByIdsForSRelay(List<ulong> routeIds);
Task<List<ulong>> GetIdsForAll();
Task<string> GetNameById(ulong id);
```

#### **3. Dictionary 返り値の場合**

Dictionary を返すメソッドは、キー部分に **`For`** を使用し、フィルタ条件部分に **`By`** を使用します。

**重要なルール:**
- **フィルタ条件なし**: `GetAllForKey` (Entity全体) または `GetAll{Property}ForKey` (特定プロパティ)
- **フィルタ条件あり**: `GetForKeyByFilter` (Entity全体) または `Get{Property}ForKeyByFilter` (特定プロパティ)
- `Dictionary<TKey, List<TValue>>` の場合も同じルールを適用
- 通常のメソッド（`GetByKey`）との区別: `GetByKey` は Entity を返し、`GetAllForKey` は Dictionary を返す

| パターン | 命名ルール | 例 |
|---------|----------|---|
| **Dictionary全体（フィルタなし）** | `GetAllForKey` | `GetAllForStationId` |
| **Dictionary全体（フィルタあり）** | `GetForKeyByFilter` | `GetForStationIdByType` |
| **Dictionaryプロパティ（フィルタなし）** | `GetAll{Property}ForKey` | `GetAllIdsForStationId`, `GetAllNamesForStationId` |
| **Dictionaryプロパティ（フィルタあり）** | `Get{Property}ForKeyByFilter` | `GetIdsForStationIdByType`, `GetNamesForIdByStationId` |

```csharp
// ✅ Good: Dictionary<TKey, TValue> - フィルタ条件なし
Task<Dictionary<string, Route>> GetAllForStationId();  // 全てのEntityをStationIdでキー化
Task<Dictionary<ulong, string>> GetAllNamesForId();  // 全てのName（プロパティ）をIdでキー化

// ✅ Good: Dictionary<TKey, TValue> - フィルタ条件あり
Task<Dictionary<string, Route>> GetForStationIdByType(RouteType type);  // Type でフィルタ
Task<Dictionary<ulong, string>> GetNamesForIdByStationId(string stationId);  // StationId でフィルタ

// ✅ Good: Dictionary<TKey, List<TValue>> - フィルタ条件なし
Task<Dictionary<string, List<Route>>> GetAllForStationId();  // StationId でグループ化（全Entity）
Task<Dictionary<string, List<ulong>>> GetAllIdsForStationId();  // StationId でグループ化（全ID）
Task<Dictionary<string, List<string>>> GetAllNamesForStationId();  // StationId でグループ化（全Name）

// ✅ Good: Dictionary<TKey, List<TValue>> - フィルタ条件あり
Task<Dictionary<ulong, List<Route>>> GetForLeverIdByStationId(string stationId);  // StationId でフィルタ
Task<Dictionary<string, List<ulong>>> GetIdsForStationIdByType(RouteType type);  // Type でフィルタ
Task<Dictionary<ulong, List<ulong>>> GetIdsForLeverIdByIds(List<ulong> routeIds);  // Ids でフィルタ

// ❌ Bad: キー部分に "By" を使用（混乱を招く）
Task<Dictionary<string, Route>> GetAllByStationId();  // キーが StationId か不明瞭
Task<Dictionary<ulong, List<Route>>> GetByLeverIdByStationId(string stationId);  // どちらがキーか不明
Task<Dictionary<string, List<ulong>>> GetIdsByStationId();  // List<ulong> を返すように見える

// ❌ Bad: フィルタなしで "GetAll" やプロパティ名を省略
Task<Dictionary<string, Route>> GetForStationId();  // GetAllForStationId であるべき
Task<Dictionary<string, List<string>>> GetForStationId();  // GetAllNamesForStationId であるべき

// ❌ Bad: フィルタありで "All" を使用（プロパティ名は OK）
Task<Dictionary<string, Route>> GetAllForStationIdByType(RouteType type);  // GetForStationIdByType であるべき
Task<Dictionary<string, List<ulong>>> GetIdsForStationIdByType(RouteType type);  // これは OK！（Ids はプロパティ名）

// ✅ 比較: 非 Dictionary 返り値は "By" を使用
Task<Route> GetByStationId(string stationId);  // 単一 Entity を返す
Task<List<Route>> GetByStationIds(List<string> stationIds);  // List を返す
Task<List<ulong>> GetIdsByStationId(string stationId);  // ID の List を返す
```

#### **5. State の Include ルール**

**StateがあるEntityは、必ずStateをIncludeすること**

- Stateエンティティを持つEntityを取得する場合、常に `.Include(e => e.State)` を行う
- メソッド名に `WithState` を付ける必要はない（常にIncludeされるため）
- State以外の関連エンティティをIncludeする場合のみ、`WithXXX` を追加する

```csharp
// ✅ Good: StateがあるEntityは常にStateをInclude
public async Task<Route?> GetById(ulong id)
{
    return await context.Routes
        .Include(r => r.RouteState)  // 必ずInclude
        .FirstOrDefaultAsync(r => r.Id == id);
}

public async Task<List<Route>> GetByIds(List<ulong> ids)
{
    return await context.Routes
        .Include(r => r.RouteState)  // 必ずInclude
        .Where(r => ids.Contains(r.Id))
        .ToListAsync();
}

// ✅ Good: State以外の関連エンティティをIncludeする場合は明示
public async Task<Route?> GetByIdWithSignal(ulong id)
{
    return await context.Routes
        .Include(r => r.RouteState)  // Stateは常にInclude
        .Include(r => r.Signal)      // Signalは明示的に追加
        .FirstOrDefaultAsync(r => r.Id == id);
}

// ❌ Bad: StateをIncludeしない
public async Task<Route?> GetById(ulong id)
{
    return await context.Routes
        .FirstOrDefaultAsync(r => r.Id == id);  // RouteStateがnullになる
}
```

#### **6. 更新・削除メソッド**

| 操作 | 命名ルール | 例 |
|------|----------|---|
| **一括更新** | `Update{Property}ByXXX` / `Set{Property}WhereXXX` | `UpdateStateByIds`, `SetNoneWhereKaijoOrTorikeshi` |
| **一括削除** | `DeleteByXXX` / `DeleteWhereXXX` | `DeleteByTrainId`, `DeleteWhereExpired` |
| **リレー操作** | `Raise{Relay}WhereXXX` / `Drop{Relay}WhereXXX` | `RaiseLeverRelayWhereCondition`, `DropRouteRelayWhereRouteRelayWithoutSwitchingMachineIsDropped` |

```csharp
// ✅ Good: ExecuteUpdate/ExecuteDelete パターン
Task DropRouteRelayWhereRouteRelayWithoutSwitchingMachineIsDropped();
Task DropThrowOutSRelayExceptByIds(List<ulong> targetIds);
Task DeleteByTrainId(long trainId);

// ❌ Bad: 曖昧な命名
Task UpdateRoutes(List<ulong> ids);  // 何を更新するか不明
Task Delete(long id);  // 何で削除するか不明
```

#### **命名規則まとめ**

```csharp
// Repositories/Route/IRouteRepository.cs より実例

// 1️⃣ Entity本体を取得
Task<List<Route>> GetByIdsWithState(List<ulong> ids);
Task<List<Route>> GetByTcNameWithState(string tcName);
Task<List<Route>> GetByStationIds(List<string> stationIds);
Task<List<Route>> GetWhereApproachLockMSRelayIsRaised();

// 2️⃣ 特定プロパティ（ID）を取得
Task<List<ulong>> GetIdsWhereLeverRelayIsRaised();
Task<List<ulong>> GetIdsWhereRouteRelayIsRaised();
Task<List<ulong>> GetIdsForAll();
Task<List<ulong>> GetIdsByIdsForSRelay(List<ulong> routeIds);

// 3️⃣ 一括更新（ExecuteUpdate）
Task DropRouteRelayWhereRouteRelayWithoutSwitchingMachineIsDropped();
Task DropSignalRelayWhereRouteRelayIsDropped();
Task DropThrowOutSRelayExceptByIds(List<ulong> targetIds);
```

### 5.2 ExecuteUpdate/ExecuteDelete の使用

**特定条件に基づいた一括更新・削除には、`ExecuteUpdateAsync` / `ExecuteDeleteAsync` を使用すること**

- SELECT → UPDATE/DELETE の2往復を避け、1クエリで完結
- パフォーマンス向上とトランザクション整合性の確保
- EF Core 7.0 以降で利用可能

#### 一括更新の例

```csharp
// ✅ Good: ExecuteUpdateAsync で一括更新 (Repositories/OperationNotification/OperationNotificationRepository.cs)
public async Task SetNoneWhereKaijoOrTorikeshiAndOperatedBeforeOrEqual(DateTime operatedAt)
{
    await context.OperationNotificationStates
        .Where(s =>
            (s.Type == OperationNotificationType.Kaijo || s.Type == OperationNotificationType.Torikeshi)
            && s.OperatedAt <= operatedAt)
        .ExecuteUpdateAsync(s => s
            .SetProperty(ons => ons.Type, OperationNotificationType.None)
            .SetProperty(ons => ons.Content, string.Empty)
        );
}

// ❌ Bad: SELECT → UPDATE の2往復
public async Task SetNoneWhereKaijoOrTorikeshiAndOperatedBeforeOrEqual(DateTime operatedAt)
{
    var states = await context.OperationNotificationStates
        .Where(s =>
            (s.Type == OperationNotificationType.Kaijo || s.Type == OperationNotificationType.Torikeshi)
            && s.OperatedAt <= operatedAt)
        .ToListAsync();

    foreach (var state in states)
    {
        state.Type = OperationNotificationType.None;
        state.Content = string.Empty;
    }
    await context.SaveChangesAsync();
}
```

#### 一括削除の例

```csharp
// ✅ Good: ExecuteDeleteAsync で一括削除 (Repositories/TrainCar/TrainCarRepository.cs)
public async Task DeleteByTrainId(long trainId)
{
    await context.TrainCarStates
        .Where(car => car.TrainStateId == trainId)
        .ExecuteDeleteAsync();
}

// ❌ Bad: SELECT → DELETE の2往復
public async Task DeleteByTrainId(long trainId)
{
    var trainCars = await context.TrainCarStates
        .Where(car => car.TrainStateId == trainId)
        .ToListAsync();
    context.TrainCarStates.RemoveRange(trainCars);
    await context.SaveChangesAsync();
}
```

#### ExecuteUpdate/ExecuteDelete を使うべきでないケース

以下のケースでは `GeneralRepository` を使用してエンティティを取得→更新→保存するパターンを使います：

**1. 更新前の値を取得する必要がある場合**

```csharp
// ✅ Good: GeneralRepositoryを使用 (Services/InterlockingService.cs)
public async Task<InterlockingLeverData> SetPhysicalLeverData(InterlockingLeverData leverData)
{
    var lever = await leverRepository.GetLeverByNameWithState(leverData.Name);
    if (lever == null)
    {
        throw new ArgumentException("Invalid lever name");
    }

    // 更新前の値を取得してログ出力
    var oldState = lever.LeverState.IsReversed;
    lever.LeverState.IsReversed = leverData.State;

    if (oldState != leverData.State)
    {
        logger.LogInformation("Lever {LeverName} state changed: {OldState} -> {NewState}",
            leverData.Name, oldState, leverData.State);
    }

    await generalRepository.Save(lever.LeverState);
    return ToLeverData(lever);
}

// ❌ Bad: ExecuteUpdateでは更新前の値が取得できない
public async Task SetPhysicalLeverData(InterlockingLeverData leverData)
{
    // 更新前の値を記録できない！
    await context.LeverStates
        .Where(ls => ls.Name == leverData.Name)
        .ExecuteUpdateAsync(ls =>
            ls.SetProperty(l => l.IsReversed, leverData.State)
        );
}
```

**2. 複雑なビジネスロジックを含む場合**

```csharp
// ✅ Good: エンティティを取得してロジック実行
public async Task UpdateTrainPosition(ulong trainId, Position newPosition)
{
    var train = await trainRepository.GetByIdWithState(trainId);

    // 複雑なビジネスロジック
    if (train.TrainState.CurrentPosition.IsNearStation())
    {
        train.TrainState.Speed = CalculateApproachSpeed(train);
    }

    train.TrainState.CurrentPosition = newPosition;
    train.TrainState.LastUpdated = DateTime.UtcNow;

    await generalRepository.Save(train.TrainState);
}
```

**3. 単一エンティティの更新の場合**

```csharp
// ✅ Good: 単一エンティティはGeneralRepositoryで十分
public async Task UpdateLeverState(ulong leverId, LCR newState)
{
    var lever = await leverRepository.GetByIdWithState(leverId);
    lever.LeverState.IsReversed = newState;
    await generalRepository.Save(lever.LeverState);
}

// ❌ Overkill: 単一エンティティにExecuteUpdateは過剰
public async Task UpdateLeverState(ulong leverId, LCR newState)
{
    await context.LeverStates
        .Where(ls => ls.LeverId == leverId)
        .ExecuteUpdateAsync(ls => ls.SetProperty(l => l.IsReversed, newState));
}
```

**まとめ:**
- **ExecuteUpdate/ExecuteDelete**: 条件に基づく一括更新・削除に最適
- **GeneralRepository**: 単一エンティティ、更新前後の値が必要、複雑なロジックを含む場合

### 5.3 Service の責務

- 複雑なビジネスロジックを実装
- 複数Repositoryを組み合わせる
- トランザクション管理
- Hubから呼び出される
- **❌ DbContext を直接利用してはいけない** - 必ずRepository経由でアクセス

```csharp
// ✅ Good: Service層でRepositoryを利用
public class RouteService(IRouteRepository routeRepository)
{
    public async Task<List<RouteData>> GetActiveRoutes()
    {
        // Repositoryを通じてデータアクセス
        var routeIds = await routeRepository.GetIdsWhereRouteRelayWithoutSwitchingMachineIsRaised();
        var routes = await routeRepository.GetByIdsWithState(routeIds);
        return routes.Select(ToRouteData).ToList();
    }

    private static RouteData ToRouteData(Route route)
    {
        return new()
        {
            TcName = route.TcName,
            RouteType = route.RouteType,
            RouteState = new()
            {
                IsLeverRelayRaised = route.RouteState.IsLeverRelayRaised,
                IsRouteRelayRaised = route.RouteState.IsRouteRelayRaised
            }
        };
    }
}

// ❌ Bad: ServiceでDbContextを直接利用
public class RouteService(ApplicationDbContext context)
{
    public async Task<List<RouteData>> GetActiveRoutes()
    {
        // DbContextを直接使用するのはNG!
        var routes = await context.Routes
            .Include(r => r.RouteState)
            .Where(r => r.RouteState.IsRouteRelayRaised == RaiseDrop.Raise)
            .ToListAsync();
        // ...
    }
}
```

## 6. ログ出力

### 6.1 基本ルール

- `ILogger<T>` を使用
- ログレベルを適切に設定（Debug, Information, Warning, Error, Critical）
- センシティブ情報（パスワード、トークン）をログに出力しない
- 構造化ログを活用（プレースホルダー使用）

### 6.2 良い例 / 悪い例

```csharp
// ✅ Good: 構造化ログ
_logger.LogInformation("Route {RouteId} has been set successfully", routeId);
_logger.LogError(ex, "Failed to set route {RouteId}", routeId);

// ❌ Bad: 文字列結合
_logger.LogInformation("Route " + routeId + " has been set successfully");

// ❌ Bad: センシティブ情報を出力
_logger.LogInformation("User password: {Password}", password);  // NG!
```

### 6.3 ログレベルの使い分け

| レベル | 用途 | 例 |
|--------|------|---|
| `Trace` | 最も詳細なデバッグ情報 | メソッド呼び出しトレース |
| `Debug` | 開発時のデバッグ情報 | クエリ実行内容、変数値 |
| `Information` | 一般的な情報 | リクエスト受信、処理完了 |
| `Warning` | 警告（処理は継続） | リトライ発生、予期しないデータ |
| `Error` | エラー（処理失敗） | 例外発生、処理失敗 |
| `Critical` | クリティカルエラー | システム停止レベルの障害 |

---

## 7. データベースマイグレーション

### 7.1 基本フロー

1. `schema.sql` を手動編集
2. `atlas migrate diff` でマイグレーション生成
3. `atlas migrate apply` で適用

### 7.2 ルール

- ✅ `schema.sql` のみを編集し、Atlasに自動生成させる
- ✅ マイグレーション名は意味のある名前を付ける

```bash
# ✅ Good: 意味のある名前
atlas migrate diff --env local add_train_signal_state_table

# ❌ Bad: 意味不明な名前
atlas migrate diff --env local update
```

---

## 8. テストコード

### 8.1 テスト戦略

| テスト種別 | プロジェクト | 対象 |
|-----------|------------|------|
| **統合テスト（IT）** | `Traincrew_MultiATS_Server.IT` | Hubエンドポイント、Controllerエンドポイント、複数層にまたがるロジック |
| **ユニットテスト（UT）** | `Traincrew_MultiATS_Server.UT` | 独立したロジック、ホストサービス |

### 8.2 テスト命名規則

```csharp
// ✅ Good: メソッド名でテスト内容が理解できる
[Fact]
public async Task SetRoute_WhenRouteExists_ShouldReturnSuccess()
{
    // Arrange
    var routeId = 1UL;
    // Act
    var result = await _routeService.SetRoute(routeId);
    // Assert
    Assert.True(result.IsSuccess);
}

// ❌ Bad: 意味不明なテスト名
[Fact]
public async Task Test1()
{
    // ...
}
```

### 8.3 AAA パターン

- **Arrange**: テスト準備
- **Act**: テスト実行
- **Assert**: 検証

```csharp
[Fact]
public async Task GetRouteById_WhenRouteNotFound_ShouldReturnNull()
{
    // Arrange
    var nonExistentRouteId = 99999UL;

    // Act
    var route = await _routeRepository.GetById(nonExistentRouteId);

    // Assert
    Assert.Null(route);
}
```

---

## 9. コード整形

### 9.1 EditorConfig

- プロジェクトルートに `.editorconfig` を配置
- インデント: 4スペース
- 改行コード: CRLF

---

## 10. 禁止事項

### 10.1 アーキテクチャ違反

- ❌ DbContextをController/Hubで直接利用
- ❌ DbContextをServiceで直接利用
- ❌ Service層をスキップしてRepositoryを直接Hubから呼ぶ

### 10.2 データベース関連

- ❌ マイグレーションファイルを手動編集
- ❌ `appsettings.json` に秘匿情報（パスワード、APIキー）をコミット
  - 代わりに環境変数または User Secrets を使用

### 10.3 非同期処理

- ❌ 非同期メソッドで `.Result` / `.Wait()` 使用（デッドロックリスク）
- ❌ `async void` メソッド（例外がキャッチできない）
  - `async Task` を使用すること

### 10.4 パフォーマンス

- ❌ 一括更新・削除でSELECT → UPDATE/DELETE パターン
  - `ExecuteUpdateAsync` / `ExecuteDeleteAsync` を使用すること
- ❌ 取得時のN+1問題が発生するコードの禁止

**N+1問題の例:**

```csharp
// ❌ Bad: N+1問題 - ループ内でクエリを発行
public async Task<List<RouteData>> GetRoutesWithSignals()
{
    var routes = await context.Routes.ToListAsync();  // 1回のクエリ
    var result = new List<RouteData>();

    foreach (var route in routes)  // N回のループ
    {
        // 各ループでクエリが発行される = N+1問題!
        var signal = await context.Signals.FindAsync(route.SignalId);
        result.Add(new RouteData
        {
            RouteName = route.Name,
            SignalName = signal?.Name
        });
    }
    return result;
}

// ✅ Good: Include で事前ロード
public async Task<List<RouteData>> GetRoutesWithSignals()
{
    var routes = await context.Routes
        .Include(r => r.Signal)  // 関連エンティティを1回のクエリで取得
        .ToListAsync();

    return routes.Select(route => new RouteData
    {
        RouteName = route.Name,
        SignalName = route.Signal?.Name
    }).ToList();
}

// ✅ Good: IDリストで一括取得
public async Task<List<RouteData>> GetRoutesWithSignals()
{
    var routes = await context.Routes.ToListAsync();
    var signalIds = routes.Select(r => r.SignalId).ToList();

    // IDリストで一度に全Signal を取得
    var signals = await context.Signals
        .Where(s => signalIds.Contains(s.Id))
        .ToListAsync();

    var signalDict = signals.ToDictionary(s => s.Id);

    return routes.Select(route => new RouteData
    {
        RouteName = route.Name,
        SignalName = signalDict.GetValueOrDefault(route.SignalId)?.Name
    }).ToList();
}
```

---

## 11. 推奨プラクティス

### 11.1 using ディレクティブ

- ファイルスコープ using を推奨（C# 10）

```csharp
// ✅ Good: ファイルスコープ
using Traincrew_MultiATS_Server.Models;
using Traincrew_MultiATS_Server.Repositories;

namespace Traincrew_MultiATS_Server.Services;

public class RouteService
{
    // ...
}
```

### 11.2 var の使用

- 型が明らかな場合は `var` を使用
- 型が不明瞭な場合は明示的に型を記述

- 一般に`var`を使用し、コンパイルエラーが発生した場合は明示的に書く

```csharp
// ✅ Good: 型が明らか
var route = new Route();
var routes = await _context.Routes.ToListAsync();
```

## 12. まとめ

このコーディング規約は、以下を目的としています：

1. **一貫性**: チーム全体で統一されたコードスタイル
2. **可読性**: 他の開発者が理解しやすいコード
3. **保守性**: 変更に強く、拡張しやすいコード
4. **品質**: バグが少なく、パフォーマンスの良いコード

規約を守ることで、長期的なプロジェクトの成功に貢献できます。

---

## 13. 次のステップ

- **04_アーキテクチャ設計.md**: プロジェクト全体のアーキテクチャを理解
- **05_テスト戦略.md**: テストの書き方と実行方法
