# 05_テスト戦略

## 概要

このドキュメントでは、Traincrew_MultiATS_Server プロジェクトにおけるテスト戦略、テストの書き方、実行方法について説明します。

---

## 1. テスト方針

### 1.1 テストピラミッド

```
        ┌──────────────┐
        │      IT      │  ← 中程度
        │  統合テスト   │
        ├──────────────┤
        │      UT      │  ← 多数
        │ユニットテスト │
        └──────────────┘
```

**注意:** E2Eテストは現在実施していません。

### 1.2 テスト種別

| テスト種別 | プロジェクト | 対象 | 実行速度 |
|-----------|------------|------|---------|
| **ユニットテスト（UT）** | `Traincrew_MultiATS_Server.UT` | 独立したロジック、HostedService | 高速 |
| **統合テスト（IT）** | `Traincrew_MultiATS_Server.IT` | Hub、Controller、複数層にまたがるロジック | 中速 |

---

## 2. プロジェクト構成

### 2.1 Traincrew_MultiATS_Server.UT（ユニットテスト）

```
Traincrew_MultiATS_Server.UT/
└── HostedService/
    └── InitDbHostedServiceTest.cs  # DB初期化サービステスト
```

**対象:**
- 独立した単一クラスのロジック
- 外部依存（DB、ネットワーク）を持たないコード
- ホストサービスのビジネスロジック

### 2.2 Traincrew_MultiATS_Server.IT（統合テスト）

```
Traincrew_MultiATS_Server.IT/
├── Collection/             # Xunit Collectionフィクスチャ
│   └── WebApplicationCollection.cs
├── Controller/             # Controllerテスト
│   └── PassengerControllerTest.cs
├── Fixture/                # テストフィクスチャ
│   └── WebApplicationFixture.cs
├── Hubs/                   # SignalR Hubテスト
│   ├── CommanderTableHubTest.cs
│   ├── CTCPHubTest.cs
│   ├── InterlockingHubTest.cs
│   ├── TIDHubTest.cs
│   └── TrainHubTest.cs
├── InterlockingLogic/      # 連動ロジックテスト
│   ├── InterlockingLogicTest.cs
│   └── RouteTestCase.cs
├── Logic/                  # ビジネスロジックテスト
│   └── LogicTest_TH71.cs
└── TestUtilities/          # テストユーティリティ
    └── RouteTestCaseGenerator.cs
```

**対象:**
- SignalR Hub エンドポイント
- HTTP API Controller
- 複数層（Service → Repository → DB）にまたがるロジック
- データベースアクセスを含む処理
- 連動ロジックの統合テスト

---

## 3. テストフレームワーク

### 3.1 使用ライブラリ

| ライブラリ | 用途 |
|-----------|------|
| **xUnit** | テストフレームワーク |
| **Moq** | モッキングライブラリ |
| **WebApplicationFactory** | ASP.NET Core統合テスト用ファクトリ |
| **SignalR Client** | SignalR Hubテスト用クライアント |

### 3.2 テスト属性

| 属性 | 用途 |
|------|------|
| `[Fact]` | 単一のテストメソッド |
| `[Theory]` | パラメータ化テスト |
| `[InlineData]` | Theory用のインラインデータ |
| `[Collection]` | テストコレクション（フィクスチャ共有） |

---

## 4. ユニットテスト（UT）の書き方

### 4.1 基本構造（AAA パターン）

```csharp
[Fact]
public void TestMethodName_WhenCondition_ShouldExpectedBehavior()
{
    // Arrange: テスト準備
    var input = "test";
    var expected = "TEST";

    // Act: テスト実行
    var actual = input.ToUpper();

    // Assert: 検証
    Assert.Equal(expected, actual);
}
```

### 4.2 命名規則

**形式:** `{メソッド名}_{条件}_{期待結果}`

**例:**
```csharp
[Fact]
public void GetRouteById_WhenRouteExists_ShouldReturnRoute()
{
    // ...
}

[Fact]
public void GetRouteById_WhenRouteNotFound_ShouldReturnNull()
{
    // ...
}

[Fact]
public void SetRoute_WhenLeverRelayRaised_ShouldSetRouteSuccessfully()
{
    // ...
}
```

### 4.3 モックの使用

**Moq を使った依存関係のモック化:**

```csharp
[Fact]
public async Task SetRoute_WhenRouteExists_ShouldCallSignalRepository()
{
    // Arrange
    var mockRouteRepo = new Mock<IRouteRepository>();
    var mockSignalRepo = new Mock<ISignalRepository>();
    var mockTransactionRepo = new Mock<ITransactionRepository>();

    var route = new Route { Id = 1, SignalId = 10 };
    mockRouteRepo
        .Setup(r => r.GetById(1))
        .ReturnsAsync(route);

    var service = new RouteService(
        mockRouteRepo.Object,
        mockSignalRepo.Object,
        mockTransactionRepo.Object
    );

    // Act
    await service.SetRoute(1);

    // Assert
    mockSignalRepo.Verify(
        s => s.UpdateSignalAspect(10, "Proceed"),
        Times.Once
    );
}
```

### 4.4 パラメータ化テスト

```csharp
[Theory]
[InlineData(RaiseDrop.Raise, true)]
[InlineData(RaiseDrop.Drop, false)]
public void IsLeverRelayRaised_ShouldReturnCorrectValue(RaiseDrop raiseDrop, bool expected)
{
    // Arrange
    var routeState = new RouteState { IsLeverRelayRaised = raiseDrop };

    // Act
    var actual = routeState.IsLeverRelayRaised == RaiseDrop.Raise;

    // Assert
    Assert.Equal(expected, actual);
}
```

---

## 5. 統合テスト（IT）の書き方

### 5.1 WebApplicationFixture の使用

統合テストでは、`WebApplicationFactory` を使用してアプリケーション全体をテスト環境で起動します。

**Fixture定義:**
```csharp
public class WebApplicationFixture : WebApplicationFactory<Program>
{
    protected override void ConfigureWebHost(IWebHostBuilder builder)
    {
        builder.ConfigureServices(services =>
        {
            // テスト用DB接続文字列を設定
            // テスト用サービスを差し替え
        });
    }
}
```

**Collection定義:**
```csharp
[CollectionDefinition("WebApplication")]
public class WebApplicationCollection : ICollectionFixture<WebApplicationFixture>
{
    // このクラスはマーカーとして機能
}
```

### 5.2 SignalR Hub テスト

```csharp
[Collection("WebApplication")]
public class InterlockingHubTest(WebApplicationFixture factory)
{
    [Fact]
    public async Task SetRoute_WhenCalled_ShouldBroadcastToAllClients()
    {
        // Arrange
        var hubConnection = new HubConnectionBuilder()
            .WithUrl("https://localhost/interlockingHub", options =>
            {
                options.HttpMessageHandlerFactory = _ => factory.Server.CreateHandler();
            })
            .Build();

        await hubConnection.StartAsync();

        var receivedRouteId = 0UL;
        hubConnection.On<ulong>("OnRouteSet", routeId =>
        {
            receivedRouteId = routeId;
        });

        // Act
        await hubConnection.InvokeAsync("SetRoute", 123UL);

        // Assert
        await Task.Delay(100); // SignalR通知を待つ
        Assert.Equal(123UL, receivedRouteId);
    }
}
```

### 5.3 HTTP Controller テスト

```csharp
[Collection("WebApplication")]
public class PassengerControllerTest(WebApplicationFixture factory)
{
    [Fact]
    public async Task GetTrainList_ShouldReturnOk()
    {
        // Arrange
        var client = factory.CreateClient();

        // Act
        var response = await client.GetAsync("/api/passenger/trains");

        // Assert
        response.EnsureSuccessStatusCode();
        var content = await response.Content.ReadAsStringAsync();
        Assert.NotEmpty(content);
    }
}
```

### 5.4 データベーステスト

統合テストでは実際のデータベース（またはテスト用DB）を使用します。

```csharp
[Collection("WebApplication")]
public class RouteRepositoryTest(WebApplicationFixture factory)
{
    [Fact]
    public async Task GetById_WhenRouteExists_ShouldReturnRoute()
    {
        // Arrange
        using var scope = factory.Services.CreateScope();
        var repository = scope.ServiceProvider.GetRequiredService<IRouteRepository>();

        // Act
        var route = await repository.GetById(1);

        // Assert
        Assert.NotNull(route);
        Assert.Equal("進路1", route.Name);
    }
}
```

---

## 6. テストの実行

### 6.1 コマンドライン実行

```bash
# 全テスト実行
dotnet test

# 特定プロジェクトのみ実行
dotnet test Traincrew_MultiATS_Server.IT
dotnet test Traincrew_MultiATS_Server.UT

# 詳細出力
dotnet test --verbosity detailed

# 並列実行無効化（デバッグ時）
dotnet test --no-parallel
```

### 6.2 IDE での実行

**JetBrains Rider:**
1. テストメソッド左側の緑色アイコンをクリック
2. または、テストエクスプローラーから実行

**Visual Studio:**
1. テストエクスプローラーを開く（Test → Test Explorer）
2. 実行したいテストを選択して実行

### 6.3 特定のテストのみ実行

```bash
# 特定のテストクラスを実行
dotnet test --filter "FullyQualifiedName~InterlockingHubTest"

# 特定のテストメソッドを実行
dotnet test --filter "FullyQualifiedName~SetRoute_WhenCalled_ShouldBroadcastToAllClients"
```

---

## 7. テストデータ管理

### 7.1 CSV ファイルからのテストデータ読み込み

統合テストでは、実際の初期データ（蓮土テーブル）を使用します。

**例:**
```csharp
public class InterlockingHubTest
{
    private List<Route> LoadRoutesFromCsv(string filePath)
    {
        using var reader = new StreamReader(filePath, Encoding.UTF8);
        using var csv = new CsvReader(reader, CultureInfo.InvariantCulture);
        return csv.GetRecords<Route>().ToList();
    }

    [Fact]
    public async Task TestAllRoutes()
    {
        var routes = LoadRoutesFromCsv("Data/RendoTable/進路.csv");
        foreach (var route in routes)
        {
            // 各進路をテスト
        }
    }
}
```

### 7.2 テストフィクスチャでのデータ準備

```csharp
public class DatabaseFixture : IDisposable
{
    public ApplicationDbContext Context { get; }

    public DatabaseFixture()
    {
        var options = new DbContextOptionsBuilder<ApplicationDbContext>()
            .UseInMemoryDatabase("TestDb")
            .Options;

        Context = new ApplicationDbContext(options);

        // テストデータ投入
        Context.Routes.Add(new Route { Id = 1, Name = "進路1" });
        Context.SaveChanges();
    }

    public void Dispose()
    {
        Context.Dispose();
    }
}
```

---

## 8. カバレッジ測定

### 8.1 カバレッジレポート生成

```bash
# カバレッジ測定付きでテスト実行
dotnet test --collect:"XPlat Code Coverage"

# レポート生成（reportgenerator が必要）
dotnet tool install -g dotnet-reportgenerator-globaltool

reportgenerator \
  -reports:"**/coverage.cobertura.xml" \
  -targetdir:"coveragereport" \
  -reporttypes:Html

# レポート表示
open coveragereport/index.html  # macOS
start coveragereport/index.html  # Windows
```

### 8.2 カバレッジ目標

| レイヤー | 目標カバレッジ |
|---------|---------------|
| **Service層** | 80% 以上 |
| **Repository層** | 70% 以上 |
| **Hub層** | 60% 以上 |
| **全体** | 70% 以上 |

---

## 9. テストのベストプラクティス

### 9.1 DRY原則（Don't Repeat Yourself）

共通処理はヘルパーメソッドに抽出します。

```csharp
// ✅ Good: ヘルパーメソッド使用
public class RouteServiceTest
{
    private RouteService CreateService(
        Mock<IRouteRepository>? routeRepo = null,
        Mock<ISignalRepository>? signalRepo = null)
    {
        return new RouteService(
            routeRepo?.Object ?? new Mock<IRouteRepository>().Object,
            signalRepo?.Object ?? new Mock<ISignalRepository>().Object,
            new Mock<ITransactionRepository>().Object
        );
    }

    [Fact]
    public async Task SetRoute_Test1()
    {
        var service = CreateService();
        // テスト実行
    }
}
```

### 9.2 テストの独立性

各テストは他のテストに依存せず、独立して実行可能であるべきです。

```csharp
// ❌ Bad: テスト間で状態を共有
public class BadTest
{
    private static int _counter = 0;

    [Fact]
    public void Test1()
    {
        _counter++; // 他のテストに影響
        Assert.Equal(1, _counter);
    }

    [Fact]
    public void Test2()
    {
        _counter++; // 実行順序に依存
        Assert.Equal(2, _counter); // 失敗する可能性
    }
}

// ✅ Good: 各テストが独立
public class GoodTest
{
    [Fact]
    public void Test1()
    {
        var counter = 0;
        counter++;
        Assert.Equal(1, counter);
    }

    [Fact]
    public void Test2()
    {
        var counter = 0;
        counter++;
        Assert.Equal(1, counter);
    }
}
```

### 9.3 テストの可読性

テスト名とアサーションメッセージで意図を明確にします。

```csharp
// ✅ Good: 明確なテスト名とアサーション
[Fact]
public void SetRoute_WhenLeverNotRaised_ShouldThrowException()
{
    // Arrange
    var service = CreateService();

    // Act & Assert
    var exception = await Assert.ThrowsAsync<InvalidOperationException>(
        () => service.SetRoute(1)
    );
    Assert.Equal("Lever relay is not raised", exception.Message);
}
```

### 9.4 テストの高速化

- 不要なデータベースアクセスを避ける
- In-Memoryデータベースを活用
- モックを適切に使用

```csharp
// ✅ Good: In-Memoryデータベース使用
var options = new DbContextOptionsBuilder<ApplicationDbContext>()
    .UseInMemoryDatabase("TestDb")
    .Options;
var context = new ApplicationDbContext(options);
```

---

## 10. CI/CD での自動テスト

### 10.1 GitHub Actions 例

```yaml
name: Test

on: [push, pull_request]

jobs:
  test:
    runs-on: ubuntu-latest

    services:
      postgres:
        image: postgres:16.4
        env:
          POSTGRES_PASSWORD: postgres
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5

    steps:
      - uses: actions/checkout@v3

      - name: Setup .NET
        uses: actions/setup-dotnet@v3
        with:
          dotnet-version: 8.0.x

      - name: Restore dependencies
        run: dotnet restore

      - name: Build
        run: dotnet build --no-restore

      - name: Run tests
        run: dotnet test --no-build --verbosity normal

      - name: Upload coverage
        uses: codecov/codecov-action@v3
```

---

## 11. トラブルシューティング

### 11.1 テストが不安定（Flaky Test）

**症状:** 同じテストが成功したり失敗したりする

**原因:**
- 非同期処理の待機不足
- テスト間の状態共有
- タイミング依存

**解決方法:**
```csharp
// ❌ Bad: 固定待機時間
await Task.Delay(100);

// ✅ Good: 条件待機
await Task.Run(async () =>
{
    for (int i = 0; i < 10; i++)
    {
        if (condition) return;
        await Task.Delay(50);
    }
    throw new TimeoutException();
});
```

### 11.2 データベーステストが失敗

**症状:** ローカルでは成功するがCI/CDで失敗

**原因:**
- データベース接続文字列の違い
- 初期データの不一致

**解決方法:**
- 環境変数で接続文字列を切り替え
- テストフィクスチャで初期データを統一

### 11.3 SignalR Hubテストのタイムアウト

**症状:** Hub接続またはメッセージ受信でタイムアウト

**解決方法:**
```csharp
// タイムアウトを長めに設定
var cts = new CancellationTokenSource(TimeSpan.FromSeconds(30));
await hubConnection.StartAsync(cts.Token);
```

---

## 12. まとめ

### 12.1 テストの重要性

- **品質保証**: バグの早期発見
- **リファクタリング**: 安全なコード変更
- **ドキュメント**: テストコードが仕様書として機能

### 12.2 推奨事項

1. **新機能実装時**: 必ず対応するテストを書く
2. **バグ修正時**: 再発防止のためのテストを追加
3. **リファクタリング時**: 既存テストが通ることを確認
4. **定期実行**: CI/CDでテストを自動実行

---

## 13. 参考リンク

- [xUnit Documentation](https://xunit.net/)
- [Moq Documentation](https://github.com/moq/moq4)
- [ASP.NET Core Integration Tests](https://learn.microsoft.com/aspnet/core/test/integration-tests)
- [SignalR Testing](https://learn.microsoft.com/aspnet/core/signalr/testing)

---

## 14. 次のステップ

テスト戦略を理解したら、以下を実践してください：

1. 既存のテストコードを読んで理解する
2. 新機能実装時にテストを書く習慣をつける
3. カバレッジを定期的に確認し、未カバー部分を特定する
4. チーム内でテストのベストプラクティスを共有する
